.step(data-title='Answering a Support Request', 
  data-file='controllers/router.js')
  :markdown
    ## Answering a Support Request

    Now that we've seen how a customer can request video support, let's take a look at how we answer that request and initiate a video call.  Here's how the interaction works at a high level (click to make it bigger):

    ![//s3.amazonaws.com/howtodocs/video-service-agent-flow.png](//s3.amazonaws.com/howtodocs/video-service-agent-flow.png)

    Our agent will view a page for a support ticket, and the JavaScript running on that page will immediately try and connect to the customer with a video call.  The agent will also be able to view the same product details as the customer, so they can provide informed support based on where the customer is inside the application

    Let's take a look at the code necessary to drive each step of this experience.

.step(data-title='Agent UI Routes', 
  data-file='controllers/router.js', data-highlight='26-30')
  :markdown
    ## Agent UI Routes

    To power our agent experience, we need to handle two routes - one for the list of support requests, and another to display an individual support request. Much like the product list, we won't delive too deeply into how the list of tickets is displayed. We're reading the tickets out of a database and displaying them in an HTML table.

    Let's begin instead by looking at how we render a ticket page, the second of these two routes. We use the same `token` middleware as before to create an ID for our agent. We also fetch data from the Star Wars API to get information on the ship the current customer is viewing.

    Most of the action for the call is happening on the client side, though, so let's dive into the browser code to see what's going on!

.step(data-title='Shared Code for Customer and Agent', 
  data-file='public/js/video.js')
  :markdown
    ## Shared Code for Customer and Agent

    The video partial, which is used for both the customer and the agent views, includes this JavaScript file. It adds shared logic that will be needed for both parts of the UI.  Let's check these pieces out first.

.step(data-title='Initializing the Twilio JavaScript SDK', 
  data-file='public/js/video.js', data-highlight='26-27')
  :markdown
    ## Initializing the Twilio JavaScript SDK

    For the agent (and for customers) the first order of business is to create an `Endpoint` to represent the current person viewing the page. We create one here, passing in the window-scoped access token (JWT string) we created on the server.

.step(data-title='Accepting an Inbound Call', 
  data-file='public/js/video.js', data-highlight='29-33')
  :markdown
    ## Accepting an Inbound Call

    Immediately after creating the Endpoint, we regiser a listener that will be fired on any incoming vieo call invitations. For this example, we automatically accept the invite.

.step(data-title='Displaying Video Streams', 
  data-file='public/js/video.js', data-highlight='4-21')
  :markdown
    ## Displaying Video Streams

    To display both parties in the video call, the logic is the same whether you initated the conversation, or you accepted an invitation. The Twilio JS SDK will append a video tag to an element of your choosing containing data from your own local web cam, and the stream coming from the person you are calling.

.step(data-title='Making an Outbound Call', 
  data-file='public/js/ticket.js', data-highlight='5-8')
  :markdown
    ## Making an Outbound Call

    In the support agent UI, we immediately attempt to place an outbound call to the endpoint ID associated with the ticket. We inserted `ticketEndpoint` into the template when the agent page was displayed, much like we did with our access token.

.step(data-title='All Done!', 
  data-file='public/js/ticket.js')
  :markdown
    ## All Done!

    And with a fraction of the code and none of the infrastructure you would need to roll your own WebRTC-powered video call, we've integrated live, in-context video support into our application. And this is just the beginning - you could combine this API with [TaskRouter](https://www.twilio.com/taskrouter) for more advanced work distribution for your agents, and begin to leverage other WebRTC features not used here.

    We'd love to hear what you thought of this tutorial. Hit us up [on Twitter @twilio](https://twitter.com/twilio) or [send us a note](mailto:help@twilio.com). Thanks for reading!